use crate::models::{DemandCurve, PortfolioGroup};
use std::hash::Hash;

/// Represents a demand entity in the flow trading system.
///
/// A demand captures a bidder's interest in acquiring products through the system.
/// Each demand is owned by a single bidder and can optionally include:
/// - A demand curve that defines pricing preferences
/// - A portfolio group that links this demand to one or more portfolios
#[cfg_attr(
    feature = "schemars",
    derive(schemars::JsonSchema),
    schemars(rename = "DemandRecord")
)]
#[cfg_attr(
    feature = "serde",
    derive(serde::Serialize),
    serde(bound(serialize = "
        DateTime: serde::Serialize,
        BidderId: serde::Serialize,
        DemandId: serde::Serialize + Clone,
        PortfolioId: serde::Serialize + Clone,
        AppData: serde::Serialize
    "))
)]
pub struct DemandRecord<
    DateTime,
    BidderId: Eq + Hash,
    DemandId: Eq + Hash,
    PortfolioId: Eq + Hash,
    AppData,
> {
    /// Unique identifier for this demand instance.
    /// Generated by the application when creating a new demand.
    pub id: DemandId,

    /// The time at which the associated value became active for the demand
    pub valid_from: DateTime,

    /// The time, if any, at which the associated value was replaced for the demand
    pub valid_until: Option<DateTime>,

    /// The bidder who owns this demand.
    pub bidder_id: BidderId,

    /// Application-specific data attached to this demand.
    /// This field allows extending the demand with custom data without
    /// modifying the core schema.
    pub app_data: AppData,

    /// Optional demand curve defining the bidder's pricing preferences.
    ///
    /// When present, this curve is used by the solver to determine optimal
    /// allocations. Setting this to `None` effectively deletes the demand
    /// from active consideration while preserving its history.
    pub curve_data: Option<DemandCurve>,

    /// Map of portfolios associated with this demand and their weights.
    ///
    /// The map keys are portfolio IDs and values are weights that determine
    /// how this demand is distributed across portfolios. An empty map means
    /// the demand is not yet associated with any portfolios.
    pub portfolio_group: PortfolioGroup<PortfolioId>,
}

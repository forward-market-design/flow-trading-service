use crate::{
    models::{DemandCurve, Sum},
    ports::Repository,
};

/// Represents a demand entity in the flow trading system.
///
/// A demand captures a bidder's interest in acquiring products through the system.
/// Each demand is owned by a single bidder and can optionally include:
/// - A demand curve that defines pricing preferences
/// - A portfolio group that links this demand to one or more portfolios
#[cfg_attr(
    feature = "schemars",
    derive(schemars::JsonSchema),
    schemars(
        rename = "DemandRecord",
        bound = "
            T::DateTime: schemars::JsonSchema,
            T::BidderId: schemars::JsonSchema,
            T::DemandId: schemars::JsonSchema,
            T::PortfolioId: schemars::JsonSchema,
            AppData: schemars::JsonSchema
        "
    )
)]
#[cfg_attr(
    feature = "serde",
    derive(serde::Serialize),
    serde(bound(serialize = "
        T::DateTime: serde::Serialize,
        T::BidderId: serde::Serialize,
        T::DemandId: serde::Serialize + Clone,
        T::PortfolioId: serde::Serialize + Clone,
        AppData: serde::Serialize
    "))
)]
pub struct DemandRecord<T: Repository, AppData> {
    /// Unique identifier for this demand instance.
    /// Generated by the application when creating a new demand.
    pub id: T::DemandId,

    /// The time at which the associated value became active for the demand
    pub valid_from: T::DateTime,

    /// The time, if any, at which the associated value was replaced for the demand
    pub valid_until: Option<T::DateTime>,

    /// The bidder who owns this demand.
    pub bidder_id: T::BidderId,

    /// Application-specific data attached to this demand.
    /// This field allows extending the demand with custom data without
    /// modifying the core schema.
    pub app_data: AppData,

    /// Optional demand curve defining the bidder's pricing preferences.
    ///
    /// When present, this curve is used by the solver to determine optimal
    /// allocations. Setting this to `None` effectively deletes the demand
    /// from active consideration while preserving its history.
    pub curve_data: DemandCurve,

    /// Map of portfolios associated with this demand and their weights.
    ///
    /// The map keys are portfolio IDs and values are weights that determine
    /// how this demand is distributed across portfolios. An empty map means
    /// the demand is not yet associated with any portfolios.
    pub portfolios: Sum<T::PortfolioId>,
}
